//  gcc -std=c99 -w -I. junkyard_20190119155625.c -lcrypto && ./a.out|less

/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <openssl/md5.h>
#define __noreturn
#define __cdecl
#define __fastcall
//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_1020();
// int printf(const char *format, ...);
// void *memset(void *s, int c, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// void __noreturn abort(void);
// int puts(const char *s);
// void __noreturn exit(int status);
// int strncmp(const char *s1, const char *s2, size_t n);
// void *malloc(size_t size);
// __int64 __fastcall EVP_DecryptInit_ex(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// void free(void *ptr);
// size_t strlen(const char *s);
// __int64 __fastcall MD5(char *dst, __int64 keylenBytes, char *md5Out);
// __int64 __fastcall EVP_DecryptFinal_ex(_QWORD, _QWORD, _QWORD); weak
// __int64 EVP_CIPHER_CTX_new(void); weak
// __int64 EVP_aes_128_cbc(void); weak
// int strcmp(const char *s1, const char *s2);
// __int64 __fastcall EVP_CIPHER_CTX_free(_QWORD); weak
// char *strncpy(char *dest, const char *src, size_t n);
// __int64 __fastcall ERR_print_errors_fp(_QWORD); weak
// __int64 __fastcall EVP_EncryptFinal_ex(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall EVP_DecryptUpdate(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// double sqrt(double x);
// __int64 __fastcall EVP_EncryptInit_ex(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall EVP_EncryptUpdate(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 (**sub_11F0())(void);
__int64 __fastcall nullsub_1(_QWORD, _QWORD); // weak
__int64 (**sub_1260())(void);
__int64 sub_12B0();
signed __int64 deadCode11();
signed __int64 sub_12EE();
signed __int64 sub_13CB();
__int64 sub_14CE();
__int64 __fastcall sub_15D8(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
signed __int64 sub_15F7();
signed __int64 sub_1686();
void __cdecl deadCode3();
__int64 __fastcall deadCode9(unsigned int a1, char *, char *);
void sub_17B4();
char *__fastcall sub_17BB(__int64 a1, unsigned int a2);
signed __int64 deadCode7();
signed __int64 sub_1A50();
__int64 deadCode5();
signed __int64 sub_1AAE();
__int64 deadCode4();
signed __int64 deadCode8();
signed __int64 sub_1C04();
signed __int64 sub_1C5B();
void sub_1D38();
__int64 sub_1D3F();
signed __int64 deadCode12();
signed __int64 deadCode10();
void sub_1E41();
unsigned __int64 sub_1E4B();
void __noreturn sub_1EEE();
__int64 __fastcall DoDecrypt(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5);
_BYTE *__fastcall sub_21B8(__int64 a1, unsigned __int64 a2);
signed __int64 __fastcall sub_2292(char a1, _BYTE *a2);
size_t __fastcall sub_2312(const char *a1, void **a2);
__int64 __fastcall DoEncyptDecrypt(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5);
void __fastcall __noreturn puts_and_exit(const char *msg, int retcode); // idb
__int64 __fastcall hexDecodeDigit(unsigned __int8 a1);
unsigned __int64 __fastcall sub_2796(const char *a1, __int64 a2, unsigned int a3, _BYTE *a4);
_BYTE *__fastcall hexDecodeAndXor(const char *key, char *inputHex, unsigned int inputLenBytes, char *dst);
_BYTE *__fastcall hexEncode(char *src, char *dst, unsigned __int64 n);
void __fastcall decryptString(int stringId, const char *CryptedStringMd5, char *dst);
void __fastcall __noreturn print_result(unsigned int stringId, unsigned int exitcode); // idb
bool __fastcall checkArg(const char *arg); // idb
__int64 __fastcall sub_303E(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_309D(unsigned __int64 a1, __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_3196(const char *a1, unsigned __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall c_DoDecrypt(__int64 a1);
__int64 sub_369D();
__int64 sub_379A();
void __fastcall __noreturn cc_DoDecrypt(const char *argv1, const char *argv2); // idb

void init(void); // idb
void fini(void); // idb
void term_proc();
// int puts(const char *s);
// __int64 __fastcall MD5(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall _cxa_finalize(_QWORD); weak
// __int64 _gmon_start__(void); weak
// __int64 ITM_deregisterTMCloneTable(void); weak

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
char a0123456789abcd[17] = "0123456789ABCDEF"; // weak
char hexadecimals[17] = "0123456789abcdef"; // weak
void *off_80E8 = &off_80E8; // weak
void *off_8140 = (void *)0xCE00000075LL; // weak
char *stringsTable[9] =

{
  "781357585f1447175d5a5852114a5c4243135d565c56",
  "7840134359524717501343564240445843570c",
  "035152030502015250025200030b000e0256010350075206035752025006075503075203025752005006075603565252",
  "66565f5b1d1340435e4313405040475e5f5413565f4a135a5e4156175e55134e5e464117455a5e5211525d53114046555c5a4717455b5617575f52501f1d1d",
  "7c524a555413475f544a144554135b5e435a5d50115247175c5013535e5d525b5514400811091c",
  "775f5a47415a5d501151464556564144115a40175f5c4717455b524311515253114a5c4211585d58461d1d19",
  "465c441b11405c17535a541610",
  "725c5e4744475a5956134043445555191f1d",
  "64405250540913191e505b565d5f13424256411741524044"
}; // weak
char *stringsMd5Table[9] =
{
  "01add5f3d30f47b2490b724d14e2f7b6",
  "2178cc1f5a91f6ccac1680d5e2db43cf",
  "27debb435021eb68b3965290b5e24c49", // "7303"
  "1eb29af45a2c5925a3b2b865460a0443",
  "76c185b3a4fd9e001602098cffca548c",
  "b8fc0a25fab72f5f587da158050bce3c",
  "6d22dfa5e406d56342cb4c422d79f9a5",
  "226aef50086d84ad958f55dc62022d3d",
  "71c897a04305a11f2e18a88c0feddc55"
};
_UNKNOWN unk_8C28; // weak
__int64 stderr; // weak
char byte_8C48; // weak
char byte_8C60[2048]; // idb


//----- (0000000000002722) ----------------------------------------------------
void __fastcall __noreturn puts_and_exit(const char *msg, int retcode)
{
  puts(msg);
  // exit(retcode);
}

//----- (000000000000275F) ----------------------------------------------------
__int64 __fastcall hexDecodeDigit(unsigned __int8 a1)
{
  if ( a1 > 0x2Fu && a1 <= '9' )
    return (unsigned int)a1 - '0';
  if ( a1 <= '9' )
    return a1;
  return (unsigned int)a1 - 0x57;
}

//----- (000000000000296B) ----------------------------------------------------
_BYTE *__fastcall hexDecodeAndXor(const char *key, char *inputHex, unsigned int inputLenBytes, char *dst)
{
  char upperNibble; // ST21_1
  _BYTE *result; // rax
  int inhexIdx; // [rsp+24h] [rbp-Ch]
  unsigned int dstIx; // [rsp+28h] [rbp-8h]
  unsigned int keylen; // [rsp+2Ch] [rbp-4h]

  keylen = strlen(key);
  dstIx = 0;
  inhexIdx = 0;
  while ( inputLenBytes > dstIx )               // hex decode
  {
    upperNibble = hexDecodeDigit(inputHex[inhexIdx]);
    dst[dstIx] = (0x10 * upperNibble + (unsigned __int64)hexDecodeDigit(inputHex[inhexIdx + 1])) ^ key[dstIx % keylen];
    inhexIdx += 2;
    ++dstIx;
  }
  result = &dst[dstIx];
  *result = 0;
  return result;
}

//----- (0000000000002A4A) ----------------------------------------------------
_BYTE *__fastcall hexEncode(char *src, char *dst, unsigned __int64 n)
{
  _BYTE *result; // rax
  int idx; // [rsp+18h] [rbp-10h]
  unsigned int idx0; // [rsp+1Ch] [rbp-Ch]

  idx = 0;
  idx0 = 0;
  while ( n > idx0 )
  {
    dst[idx] = hexadecimals[((unsigned __int8)src[idx0] >> 4) & 0xF];
    dst[idx + 1] = hexadecimals[src[idx0++] & 0xF];
    idx += 2;
  }
  result = &dst[idx];
  *result = 0;
  return result;
}

//----- (0000000000002AF8) ----------------------------------------------------
void __fastcall decryptString(int stringId, const char *CryptedStringMd5, char *dst)
{
  size_t dstLen; // rdx
  signed int v5; // eax
  unsigned int ctr_; // eax
  signed int v8; // [rsp+4Ch] [rbp-F4h]
  signed int ctr; // [rsp+58h] [rbp-E8h]
  signed int i; // [rsp+60h] [rbp-E0h]
  signed int j; // [rsp+64h] [rbp-DCh]
  size_t keylenBytes; // [rsp+68h] [rbp-D8h]
  char md5Out[16]; // [rsp+70h] [rbp-D0h]
  char buf2[22]; // [rsp+80h] [rbp-C0h]
  char buf1[28]; // [rsp+A0h] [rbp-A0h]
  char hexEncodedMd5[48]; // [rsp+C0h] [rbp-80h]
  char ctrAsString[64]; // [rsp+F0h] [rbp-50h]
  unsigned __int64 cookie; // [rsp+138h] [rbp-8h]
  int foundIt;

  ctr = 13371337;
  keylenBytes = strlen(stringsTable[stringId]) >> 1;
  do
  {
    memset(ctrAsString, 0, 0x40uLL);
    memset(md5Out, 0, 0x10uLL);
    dstLen = strlen(dst);
    memset(dst, 0, dstLen);
    for ( i = 0; i < 3; ++i )                   // deadcode
    {
      v8 = 3;
      do
        v5 = v8--;
      while ( v5 );
    }
    ctr_ = ctr++;
    snprintf(ctrAsString, 0x40uLL, "%d", ctr_); // stupid xor with this string -.-
    memcpy(buf1, "dzwqOWuKqeRDUAmLsy9JQkbg0U7Rr", 29);// WHY???
    hexDecodeAndXor(ctrAsString, stringsTable[stringId], keylenBytes, dst);
    MD5(dst, keylenBytes, md5Out);
    hexEncode(md5Out, hexEncodedMd5, 0x10uLL);
    // printf("%d %s %s\n", ctr, hexEncodedMd5, CryptedStringMd5);
    for ( j = 0; j < 5; ++j )
    {
      *(_QWORD *)buf2 = 'jbrNCGFy';
      *(_QWORD *)&buf2[8] = '8tSnJO4x';
      *(_DWORD *)&buf2[16] = 'wqFk';
      buf2[20] = 'D';                           // dead
    }
    if (ctr % 100000 == 0)
    printf("%d\n", ctr);
foundIt = strcmp(hexEncodedMd5, CryptedStringMd5) == 0;
  }
  while ( ctr > 0 && !foundIt && 0);
  printf("%d\n", ctr);
}
// 8B80: using guessed type char *stringsTable[9];

//----- (0000000000002EB3) ----------------------------------------------------
void __fastcall __noreturn print_result(unsigned int stringId, unsigned int exitcode)
{
  char msg[0x40]; // [rsp+20h] [rbp-810h]
  unsigned __int64 cookie; // [rsp+828h] [rbp-8h]

  decryptString(stringId, (stringsMd5Table)[stringId], &msg);
  puts_and_exit(&msg, exitcode);
}
// 8BE0: using guessed type char *stringsMd5Table;

int fuck(signed __int64 number)
{
  size_t arg1_len; // rax
  size_t arg2_len; // rax
  unsigned __int64 arg1_len_; // rax
  unsigned __int64 arg2_len_; // rax
  int pwFirst; // ebx
  __int64 pw2a; // STC0_8
  int digit; // ST8C_4
  signed int idx; // eax
  signed int idx_; // eax
  __int64 md5InLen; // rax
  size_t md5Len; // rax
  unsigned __int8 k; // [rsp+1Fh] [rbp-11B1h]
  signed int numberOfDigits; // [rsp+7Ch] [rbp-1154h]
  unsigned int stringId; // [rsp+80h] [rbp-1150h]
  unsigned int exitCode; // [rsp+84h] [rbp-114Ch]
  int v19; // [rsp+88h] [rbp-1148h]
  __int64 v20; // [rsp+90h] [rbp-1140h]
  unsigned __int64 j; // [rsp+98h] [rbp-1138h]
  signed __int64 numbera; // [rsp+A0h] [rbp-1130h]
  unsigned __int64 i; // [rsp+A8h] [rbp-1128h]
  char *arg1_copy; // [rsp+B0h] [rbp-1120h]
  char *arg2_copy; // [rsp+B8h] [rbp-1118h]
  __int64 stupidSum; // [rsp+C0h] [rbp-1110h]
  char md5In[5]; // [rsp+CBh] [rbp-1105h]
  __int64 v29; // [rsp+D0h] [rbp-1100h]
  __int64 v30; // [rsp+D8h] [rbp-10F8h]
  __int16 v31; // [rsp+E0h] [rbp-10F0h]
  char v32; // [rsp+E2h] [rbp-10EEh]
  _BYTE alphabet[19]; // [rsp+F0h] [rbp-10E0h]
  __int64 v34; // [rsp+110h] [rbp-10C0h]
  __int64 v35; // [rsp+118h] [rbp-10B8h]
  int v36; // [rsp+120h] [rbp-10B0h]
  __int16 v37; // [rsp+124h] [rbp-10ACh]
  char v38; // [rsp+126h] [rbp-10AAh]
  char md5Out[0x100]; // [rsp+150h] [rbp-1080h]
  char hexOut[0x100]; // [rsp+180h] [rbp-1050h]
  char hexIn[2048]; // [rsp+1B0h] [rbp-1020h]
  char dst[2056]; // [rsp+9B0h] [rbp-820h]
  unsigned __int64 v43; // [rsp+11B8h] [rbp-18h]
   snprintf(hexIn, 0x13uLL, "%lu", number);
  alphabet[0] = 'A';                            // A = -9; S = 9 probably lol
  alphabet[1] = 'B';
  alphabet[2] = 'C';
  alphabet[3] = 'D';
  alphabet[4] = 'E';
  alphabet[5] = 'F';
  alphabet[6] = 'G';
  alphabet[7] = 'H';
  alphabet[8] = 'I';
  alphabet[9] = 'J';
  alphabet[10] = 'K';
  alphabet[11] = 'L';
  alphabet[12] = 'M';
  alphabet[13] = 'N';
  alphabet[14] = 'O';
  alphabet[15] = 'P';
  alphabet[16] = 'Q';
  alphabet[17] = 'R';
  alphabet[18] = 'S';
  numberOfDigits = 0;
  v19 = number;
  while ( number && numberOfDigits <= 15 )
  {
    number = ((signed __int64)((unsigned __int128)(0x6666666666666667LL * (signed __int128)number) >> 64) >> 2)
           - (number >> 63);                    // signed division by 10
    ++numberOfDigits;
  }
  numbera = v19;
  while ( numbera && numberOfDigits <= 15 )
  {
    digit = numbera
          - 10
          * (((signed __int64)((unsigned __int128)(0x6666666666666667LL * (signed __int128)numbera) >> 64) >> 2)
           - (numbera >> 63));                  // signed modulo by 10
    numbera = ((signed __int64)((unsigned __int128)(0x6666666666666667LL * (signed __int128)numbera) >> 64) >> 2)
            - (numbera >> 63);                  // signed div by 10
    number/=10;
    idx = numberOfDigits++;
    hexIn[idx] = alphabet[digit];
  }
  while ( numberOfDigits <= 15 )
  {
    idx_ = numberOfDigits++;
    hexIn[idx_] = 'a';
  }
  // printf("%s\n", hexIn);
  hexEncode(hexIn, dst, 0x10uLL);               // example of hexIn: │9142│43DE│CEBJ│aaaa│
                                                // 914243
                                                // JBECED
                                                // offset from A in alphabet, it's stupid
  for ( k = 5; k <= 8u; ++k ) // only check 4 bytes...lol...
    md5In[k - 5] = dst[k];
  md5InLen = strlen(md5In);
  MD5(md5In, md5InLen, md5Out);
  hexEncode(md5Out, hexOut, 0x10uLL);
  md5Len = strlen(stringsMd5Table[2]);
  // printf("%s %s\n", stringsMd5Table[2],hexOut);
  if ( !strncmp(stringsMd5Table[2], hexOut, md5Len) ) // check against '  '
  {
    // printf("Omg!!! %s %s\n", stringsMd5Table[2], hexOut);
  printf("hexin: %s\n", hexIn);
  // printf("%s\n", dst);
  // printf("%s\n", md5In);
    return 1;
  }

  // NUmber must be:
  // XX XX X7 30 3X XX in hex
  // XX70Xxxxxxxxxxx
  // 10700
  return 0;
}

int main(int argc, char **argv, char **envp)
{

int i=0;
do
{
  // if((i&0xfffff)==0)printf("%x\n",i);
if(fuck(i)){
  printf("%d\n", i);
  // break;
}
}while(++i);
return 0;

  for (int i = 0; i < sizeof(stringsTable)/sizeof(char*); i++)
  {
    printf("%d\n",i);
      print_result(i,0);
  }
return 0;
}

/*
0
13371338
I don't like your name
1
13371338
Is that a password?
2
13371338
2ba4412ea1a728393e24a4a12da5a54b24a43da7a54a2eae <-- easter egg...
3
13371338
Well, stop wasting any more of your time and submit the flag...
4
13371338
Maybe they're hiring at mc donald's? :/
5
13371338
Flipping burgers is not that bad you know...
6
13371338
wow, so big!!
7
13371338
Computing stuff...
8
13371338
Usage: ./chall user pass
*/
